
//////////////////////////////////////////////////////////////////////
// DO NOT EDIT
// This code is auto-generated by generate_FaultEnglish.sh
// DO NOT EDIT
//////////////////////////////////////////////////////////////////////

static const char*
faultCodeToEnglish(pluton::faultCode fc)
{
    switch(fc) {
        case pluton::deserializeFailed             : return "deserializeFailed:De-serialization of netString packet failed";
        case pluton::unknownFunction               : return "unknownFunction:Service wildcard request with invalid function";
        case pluton::requestTooLarge               : return "requestTooLarge:Request too large";
        case pluton::remoteConnectFailed           : return "remoteConnectFailed:Could not connect to remote host";
        case pluton::remoteTransferFailed          : return "remoteTransferFailed:Write to remote socket failed mid-stream";
        case pluton::lastReservedUserFault         : return "lastReservedUserFault:If you see this - worry!";
        case pluton::alreadyInitialized            : return "alreadyInitialized:Multiple calls to ::initialize()";
        case pluton::notInitialized                : return "notInitialized:Must call ::initialize() prior to all others";
        case pluton::requestNotAdded               : return "requestNotAdded:Waiting on a request that is not in progress";
        case pluton::requestAlreadyAdded           : return "requestAlreadyAdded:Request has already been added";
        case pluton::requestInProgress             : return "requestInProgress:Request is still being sent to the service";
        case pluton::responseInProgress            : return "responseInProgress:Response has not yet been read from service";
        case pluton::unimplemented                 : return "unimplemented:Called an unimplemented method";
        case pluton::badRequestLength              : return "badRequestLength:Request Length is less than zero";
        case pluton::noAffinity                    : return "noAffinity:needAffinityAttr set on non-connected request";
        case pluton::noWaitNotAllowed              : return "noWaitNotAllowed:Cannot have noWaitAttr and keepAffinityAttr";
        case pluton::needNoRetry                   : return "needNoRetry:Must have noRetryAttr with keepAffinityAttr";
        case pluton::openSocketFailed              : return "openSocketFailed:-1 return from socket()";
        case pluton::connectFailed                 : return "connectFailed:-1 return from connect()";
        case pluton::socketWriteFailed             : return "socketWriteFailed:-1 return from socket write()";
        case pluton::socketReadFailed              : return "socketReadFailed:-1 return from socket read()";
        case pluton::serviceTimeout                : return "serviceTimeout:Caller timeout expired";
        case pluton::incompleteResponse            : return "incompleteResponse:Service closed socket with response pending";
        case pluton::responsePacketFormatError     : return "responsePacketFormatError:Response Packet format is invalid";
        case pluton::contextFormatError            : return "contextFormatError:Context data in packet is incorrect";
        case pluton::contextReservedNamespace      : return "contextReservedNamespace:Context key cannot start with .pluton";
        case pluton::setsockoptFailed              : return "setsockoptFailed:-1 return from setsockopt()";
        case pluton::fcntlFailed                   : return "fcntlFailed:-1 return from fcntl()";
        case pluton::serviceNotFound               : return "serviceNotFound:ServiceKey is not in lookupMap";
        case pluton::serviceKeyBad                 : return "serviceKeyBad:Format of serviceKey is invalid";
        case pluton::mapInitializationFailed       : return "mapInitializationFailed:Could not open/mmap the lookup map";
        case pluton::openForMmapFailed             : return "openForMmapFailed:open() prior to mmap() of lookup Path failed";
        case pluton::lookupButNoMap                : return "lookupButNoMap:Attempted lookup on non-mapped lookup Path";
        case pluton::persistentRemapFlag           : return "persistentRemapFlag:Remap flag set after remap attempt";
        case pluton::exceededRetryLimit            : return "exceededRetryLimit:Configured retry limit has been exceeded";
        case pluton::retryNotAllowed               : return "retryNotAllowed:noRetryAttr set on a request that failed";
        case pluton::remoteNotAllowed              : return "remoteNotAllowed:noRemoteAttr set on a request to be relayed";
        case pluton::writeEventForWrongFD          : return "writeEventForWrongFD:pluton::clientImpl::sendCanWriteEvent gave a bad fd";
        case pluton::readEventForWrongFD           : return "readEventForWrongFD:pluton::clientImpl::sendCanReadEvent gave a bad fd";
        case pluton::writeEventWrongState          : return "writeEventWrongState:pluton::clientImpl::writeEvent with wrong state";
        case pluton::readEventWrongState           : return "readEventWrongState:pluton::clientImpl::readEvent with wrong state";
        case pluton::openAcceptSocketFailed        : return "openAcceptSocketFailed:Could not open getenv('plutonAcceptSocket')";
        case pluton::mmapInheritedShmFDFailed      : return "mmapInheritedShmFDFailed:Could not mmap fd passed by manager";
        case pluton::getRequestNotNext             : return "getRequestNotNext:Out of sequence call to getRequest()";
        case pluton::acceptFailed                  : return "acceptFailed:accept() on listening socket failed";
        case pluton::noFauxSTDIN                   : return "noFauxSTDIN:Service needs a faux STDIN when run from the shell";
        case pluton::wrongNSType                   : return "wrongNSType:Unexpected netString type";
        case pluton::requestDecodeFailed           : return "requestDecodeFailed:Could not decode request packet";
        case pluton::requestNetStringParseError    : return "requestNetStringParseError:Parse of request packet netstring failed";
        case pluton::sendResponseNotNext           : return "sendResponseNotNext:Out of sequence call to sendResponse()";
        case pluton::sendRawResponseNotNext        : return "sendRawResponseNotNext:Out of sequence call to sendRawResponse()";
        case pluton::netStringTooLarge             : return "netStringTooLarge:buffer cannot expand to fit inbound netString";
        case pluton::unexpectedEOF                 : return "unexpectedEOF:EOF mid-way through a packet read";
        case pluton::bindFailed                    : return "bindFailed:-1 return from bind()";
        case pluton::unlinkFailed                  : return "unlinkFailed:-1 return from unlink() of named pipe";
        case pluton::listenFailed                  : return "listenFailed:-1 returned from listen()";
        case pluton::emptyIdentifier               : return "emptyIdentifier:Empty parameters given to openService()";
        case pluton::pollInterrupted               : return "pollInterrupted:-1 and EINTR returned from poll() of pipe";
        case pluton::shmFstatFailed                : return "shmFstatFailed:fstat() return -1 on mmap fd";
        case pluton::shmMmapFailed                 : return "shmMmapFailed:mmap() returned MAP_FAILED";
        case pluton::shmVersionMisMatch            : return "shmVersionMisMatch:shm verion differs from expected";
        case pluton::shmThreadConfigNotService     : return "shmThreadConfigNotService:Threaded Config mis-matches service";
        case pluton::shmThreadServiceNotConfig     : return "shmThreadServiceNotConfig:Threaded Service mis-matches config";
        case pluton::shmPreWriteFailed             : return "shmPreWriteFailed:Pre-write of mmap file failed";
        case pluton::shmImpossiblySmall            : return "shmImpossiblySmall:Lookup Map file too small to be valid";
        case pluton::seriousInternalOSError        : return "seriousInternalOSError:syscall failure";
        case pluton::seriousInternalRoutingError   : return "seriousInternalRoutingError:Response returned to wrong client";
        default: break;
    }
    return "Unknown faultCode?";
}
